diff -u linux/drivers/char/agp/agp.h linux-agp/drivers/char/agp/agp.h
--- linux/drivers/char/agp/agp.h	Thu Mar 15 19:08:11 2001
+++ linux-agp/drivers/char/agp/agp.h	Thu Mar 15 17:42:26 2001
@@ -106,7 +106,7 @@
 
 	int (*fetch_size) (void);
 	int (*configure) (void);
-	void (*agp_enable) (u32);
+	void (*agp_enable) (agp_setup *);
 	void (*cleanup) (void);
 	void (*tlb_flush) (agp_memory *);
 	unsigned long (*mask_memory) (unsigned long, int);
diff -u linux/drivers/char/agp/agpgart_be.c linux-agp/drivers/char/agp/agpgart_be.c
--- linux/drivers/char/agp/agpgart_be.c	Thu Mar 15 19:08:11 2001
+++ linux-agp/drivers/char/agp/agpgart_be.c	Thu Mar 15 19:00:44 2001
@@ -383,10 +383,14 @@
 
 /* Generic Agp routines - Start */
 
-static void agp_generic_agp_enable(u32 mode)
+static void agp_generic_agp_enable(agp_setup *modesetup)
 {
 	struct pci_dev *device = NULL;
 	u32 command, scratch, cap_id;
+	u32 mode = modesetup->agp_mode;
+	u32 bus = modesetup->bus;
+	u32 slot = modesetup->slot;
+	u32 func = modesetup->func;
 	u8 cap_ptr;
 
 	pci_read_config_dword(agp_bridge.dev,
@@ -394,72 +398,81 @@
 			      &command);
 
 	/*
-	 * PASS1: go throu all devices that claim to be
-	 *        AGP devices and collect their data.
+	 * PASS1: Find AGP device, by BusID 
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
-		pci_read_config_dword(device, 0x04, &scratch);
-
-		if (!(scratch & 0x00100000))
-			continue;
-
-		pci_read_config_byte(device, 0x34, &cap_ptr);
-
-		if (cap_ptr != 0x00) {
-			do {
-				pci_read_config_dword(device,
-						      cap_ptr, &cap_id);
+	device = pci_find_slot(bus, PCI_DEVFN(slot, func));
 
-				if ((cap_id & 0xff) != 0x02)
-					cap_ptr = (cap_id >> 8) & 0xff;
-			}
-			while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
-		}
-		if (cap_ptr != 0x00) {
-			/*
-			 * Ok, here we have a AGP device. Disable impossible 
-			 * settings, and adjust the readqueue to the minimum.
-			 */
-
-			pci_read_config_dword(device, cap_ptr + 4, &scratch);
-
-			/* adjust RQ depth */
-			command =
-			    ((command & ~0xff000000) |
-			     min((mode & 0xff000000),
-				 min((command & 0xff000000),
-				     (scratch & 0xff000000))));
-
-			/* disable SBA if it's not supported */
-			if (!((command & 0x00000200) &&
-			      (scratch & 0x00000200) &&
-			      (mode & 0x00000200)))
-				command &= ~0x00000200;
-
-			/* disable FW if it's not supported */
-			if (!((command & 0x00000010) &&
-			      (scratch & 0x00000010) &&
-			      (mode & 0x00000010)))
-				command &= ~0x00000010;
-
-			if (!((command & 4) &&
-			      (scratch & 4) &&
-			      (mode & 4)))
-				command &= ~0x00000004;
-
-			if (!((command & 2) &&
-			      (scratch & 2) &&
-			      (mode & 2)))
-				command &= ~0x00000002;
-
-			if (!((command & 1) &&
-			      (scratch & 1) &&
-			      (mode & 1)))
-				command &= ~0x00000001;
+	/* We should return failure, 
+           but it's the upper level drivers fault really */
+	if (!device) {
+		printk("Failed to initialize AGP device %d:%d:%d\n",
+					bus, slot, func);
+		return;
+	}
+
+#if 0 /* Jeff - what's this ? I can't find it in the AGP spec */
+	pci_read_config_dword(device, 0x04, &scratch);
+
+	if (!(scratch & 0x00100000))
+		continue;
+#endif
+
+	pci_read_config_byte(device, 0x34, &cap_ptr);
+
+	if (cap_ptr != 0x00) {
+		do {
+			pci_read_config_dword(device,
+					      cap_ptr, &cap_id);
+
+			if ((cap_id & 0xff) != 0x02)
+				cap_ptr = (cap_id >> 8) & 0xff;
 		}
+		while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
+	}
+	if (cap_ptr != 0x00) {
+		/*
+		 * Ok, here we have a AGP device. Disable impossible 
+		 * settings, and adjust the readqueue to the minimum.
+		 */
+
+		pci_read_config_dword(device, cap_ptr + 4, &scratch);
+
+		/* adjust RQ depth */
+		command =
+		    ((command & ~0xff000000) |
+		     min((mode & 0xff000000),
+			 min((command & 0xff000000),
+			     (scratch & 0xff000000))));
+
+		/* disable SBA if it's not supported */
+		if (!((command & 0x00000200) &&
+		      (scratch & 0x00000200) &&
+		      (mode & 0x00000200)))
+			command &= ~0x00000200;
+
+		/* disable FW if it's not supported */
+		if (!((command & 0x00000010) &&
+		      (scratch & 0x00000010) &&
+		      (mode & 0x00000010)))
+			command &= ~0x00000010;
+
+		if (!((command & 4) &&
+		      (scratch & 4) &&
+		      (mode & 4)))
+			command &= ~0x00000004;
+
+		if (!((command & 2) &&
+		      (scratch & 2) &&
+		      (mode & 2)))
+			command &= ~0x00000002;
+
+		if (!((command & 1) &&
+		      (scratch & 1) &&
+		      (mode & 1)))
+			command &= ~0x00000001;
 	}
+
 	/*
 	 * PASS2: Figure out the 4X/2X/1X setting and enable the
 	 *        target (our motherboard chipset).
@@ -481,32 +494,31 @@
 			       command);
 
 	/*
-	 * PASS3: Go throu all AGP devices and update the
-	 *        command registers.
+	 * PASS3:
+	 *  update command registers.
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
-		pci_read_config_dword(device, 0x04, &scratch);
-
-		if (!(scratch & 0x00100000))
-			continue;
-
-		pci_read_config_byte(device, 0x34, &cap_ptr);
-
-		if (cap_ptr != 0x00) {
-			do {
-				pci_read_config_dword(device,
-						      cap_ptr, &cap_id);
+#if 0 /* Jeff - what's this ? I can't find it in the AGP spec */
+	pci_read_config_dword(device, 0x04, &scratch);
 
-				if ((cap_id & 0xff) != 0x02)
-					cap_ptr = (cap_id >> 8) & 0xff;
-			}
-			while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
+	if (!(scratch & 0x00100000))
+		continue;
+#endif
+
+	pci_read_config_byte(device, 0x34, &cap_ptr);
+
+	if (cap_ptr != 0x00) {
+		do {
+			pci_read_config_dword(device,
+					      cap_ptr, &cap_id);
+
+			if ((cap_id & 0xff) != 0x02)
+				cap_ptr = (cap_id >> 8) & 0xff;
 		}
-		if (cap_ptr != 0x00)
-			pci_write_config_dword(device, cap_ptr + 8, command);
+		while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
 	}
+	if (cap_ptr != 0x00)
+		pci_write_config_dword(device, cap_ptr + 8, command);
 }
 
 static int agp_generic_create_gatt_table(void)
@@ -803,7 +815,7 @@
 
 /* End Basic Page Allocation Routines */
 
-void agp_enable(u32 mode)
+void agp_enable(agp_setup *mode)
 {
 	if (agp_bridge.type == NOT_SUPPORTED) return;
 	agp_bridge.agp_enable(mode);
@@ -909,7 +921,7 @@
 	return;
 }
 
-static void intel_i810_agp_enable(u32 mode)
+static void intel_i810_agp_enable(agp_setup *mode)
 {
 	return;
 }
diff -u linux/drivers/char/agp/agpgart_fe.c linux-agp/drivers/char/agp/agpgart_fe.c
--- linux/drivers/char/agp/agpgart_fe.c	Thu Mar 15 19:08:11 2001
+++ linux-agp/drivers/char/agp/agpgart_fe.c	Thu Mar 15 17:37:06 2001
@@ -838,7 +838,7 @@
 	if (copy_from_user(&mode, (void *) arg, sizeof(agp_setup))) {
 		return -EFAULT;
 	}
-	agp_enable(mode.agp_mode);
+	agp_enable(&mode);
 	return 0;
 }
 
diff -u linux/include/linux/agp_backend.h linux-agp/include/linux/agp_backend.h
--- linux/include/linux/agp_backend.h	Thu Mar 15 19:08:15 2001
+++ linux-agp/include/linux/agp_backend.h	Thu Mar 15 17:48:13 2001
@@ -84,6 +84,13 @@
 	int current_memory;
 } agp_kern_info;
 
+typedef struct _agp_setup {
+	u32 agp_mode;
+	u32 bus;
+	u32 slot;
+	u32 func;
+} agp_setup;
+
 /* 
  * The agp_memory structure has information
  * about the block of agp memory allocated.
@@ -195,7 +202,7 @@
  * 
  */
 
-extern void agp_enable(u32);
+extern void agp_enable(agp_setup *);
 
 /* 
  * agp_enable :
@@ -239,7 +246,7 @@
 	agp_memory *(*allocate_memory)(size_t, u32);
 	int        (*bind_memory)(agp_memory *, off_t);
 	int        (*unbind_memory)(agp_memory *);
-	void       (*enable)(u32);
+	void       (*enable)(agp_setup *);
 	int        (*acquire)(void);
 	void       (*release)(void);
 	void       (*copy_info)(agp_kern_info *);
diff -u linux/include/linux/agpgart.h linux-agp/include/linux/agpgart.h
--- linux/include/linux/agpgart.h	Mon Dec 11 20:51:40 2000
+++ linux-agp/include/linux/agpgart.h	Thu Mar 15 17:39:09 2001
@@ -69,9 +69,11 @@
 	size_t pg_used;		/* current pages used           */
 } agp_info;
 
+#if 0
 typedef struct _agp_setup {
 	__u32 agp_mode;		/* mode info of bridge          */
 } agp_setup;
+#endif
 
 /*
  * The "prot" down below needs still a "sleep" flag somehow ...
@@ -135,9 +137,11 @@
 	size_t pg_used;		/* current pages used           */
 } agp_info;
 
+#if 0
 typedef struct _agp_setup {
 	u32 agp_mode;		/* mode info of bridge          */
 } agp_setup;
+#endif
 
 /*
  * The "prot" down below needs still a "sleep" flag somehow ...
